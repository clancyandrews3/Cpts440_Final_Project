# -*- coding: utf-8 -*-
"""Final Project - CPTS440.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L1jswtjH7t1ApscdbMaMg2_svlpNgVE3

# Dots and Boxes

## Game Logic

Below is the implemented game logic for Dots and Boxes.
"""

#game simulator

import numpy as np
import random #used for randomAI

def initBoard(n):
    # n is length of struct, not grid size
    board = np.empty((n,n), object)
    availableMoves = []

    #board is a 2d array of tuples. The first term of the tuple is a char which indicated what it is (dot, horiztonal line, vertical line, or box)
    for i in range(n):
        for j in range(n):
            if i % 2 == 0:
                if j % 2 == 0:
                    board[i,j] = ("*") # for dots, have form ("*"), since they don't change at all
                else:
                    #for horizontal lines, have the form "---" if claimed or "   " if empty.
                    board[i,j] = ("   ")
                    availableMoves.append((i,j))
            else:
                if j % 2 == 0:
                    board[i,j] = (" ") #for veritcal lines, have the form "|" if claimed or " " if empty
                    availableMoves.append((i,j))
                else:
                    board[i,j] = (0) #for boxes, have the form " P " for player, " A " for AI, and the int for number of edges if not taken
    return board, availableMoves

#draw the current board
def printBoard(board, n, move, claimedBoxes):
    #print the column labels
    print("  ", end="")
    if n >= 10: #another space to deal with two digit numbers
        print(" ", end="")
    for i in range(n):
        print(i, sep="", end=" ")
    print("") #get a new line
    for i in range(n):
        #print the row labels
        print(i, end=" ")
        if n >= 10 and i < 10:
            #add another space to deal with two digit numbers
            print(" ", end="")

        #print the row
        for j in range(n):
          if ((i,j) == move or (i,j) in claimedBoxes): # if latest move or latest claimed boxes
            col = 34 #color text blue if it is new
          else:
            col = 0 #white otherwise
            isinstance(board[i,j], int)
          current = "   " if isinstance(board[i,j], int) else board[i,j]
          print(f"\033[{col}m{current}\033[0m", end="")
        print("") #get new line

def availableMove(gameBoard, move): # assume move in numerical range, checked prior
  if (move[0] % 2 and move[1] % 2): # check for box since it can be empty
    return False
  return gameBoard[move[0], move[1]].isspace()

#checks if a box is claimed
def isCompletedBox(gameBoard, boxRow, boxCol):
    return not gameBoard[boxRow-1, boxCol].isspace() and not gameBoard[boxRow+1, boxCol].isspace() and not gameBoard[boxRow, boxCol-1].isspace() and not gameBoard[boxRow, boxCol+1].isspace()

#marks a box as belonging to the player with the current turn
def claimBox(gameBoard, boxRow, boxCol, isPlayersTurn):
    #claim the box for the corresponding player
    gameBoard[boxRow, boxCol] = " P " if isPlayersTurn else " A "
    return gameBoard

#draw a line at designated move's location, claiming box as neccessary
def makeMove(gameBoard, n, move, isPlayersTurn, score):
    claimedSquares = []
    vertical = (move[0] % 2 and not move[1] % 2) # vertical at odd row, even col
    gameBoard[move[0],move[1]] = "|" if vertical else "---" #draw a line at specified move

    #determine if we've completed a box
    if vertical:  #if we've drawn a vertical line, we can only complete a box left or a box right, double check this is for vertical
        if move[1] != 0: #check box to the left
            boxRow = move[0]
            boxCol = move[1] - 1
            if gameBoard[boxRow, boxCol] == 3:
                claimedSquares.append((boxRow, boxCol))
                gameBoard = claimBox(gameBoard, boxRow, boxCol, isPlayersTurn)
            else:
              gameBoard[boxRow, boxCol] += 1

        if move[1] < n-1: #check box to the right
            boxRow = move[0]
            boxCol = move[1] + 1
            if gameBoard[boxRow, boxCol] == 3:
                claimedSquares.append((boxRow, boxCol))
                gameBoard = claimBox(gameBoard, boxRow, boxCol, isPlayersTurn)
            else:
              gameBoard[boxRow, boxCol] += 1

    else: #if we've drawn a horiztonal line, we can only complete a box above or below
        if move[0] != 0: #check box above
            boxRow = move[0] - 1
            boxCol = move[1]
            if gameBoard[boxRow, boxCol] == 3:
                claimedSquares.append((boxRow, boxCol))
                gameBoard = claimBox(gameBoard, boxRow, boxCol, isPlayersTurn)
            else:
              gameBoard[boxRow, boxCol] += 1

        if move[0] < n-1: #check box below
            boxRow = move[0] + 1
            boxCol = move[1]
            if gameBoard[boxRow, boxCol] == 3:
                claimedSquares.append((boxRow, boxCol))
                gameBoard = claimBox(gameBoard, boxRow, boxCol, isPlayersTurn)
            else:
              gameBoard[boxRow, boxCol] += 1
    score[isPlayersTurn] += len(claimedSquares)
    return gameBoard, claimedSquares

#accept player input
def playerTurn(gameBoard, n):
    while(1):
        movestr = input("Where do you want your line? Type as rownumber, columnnumber. ")
        move = movestr.replace(" ", "").split(",")
        if len(move) == 2:
            if move[0].isnumeric() and move[1].isnumeric():
                move[0] = int(move[0])
                move[1] = int(move[1])
                if (move[0] >= 0 and move[0] < n and move[1] >= 0 and move[1] < n and availableMove(gameBoard, move)): # valid numerical range and available
                    break
                else:
                  print("Move not available, Choose a row and column between two dots.")
        print("Invalid input.")

    #if we've broke out of the loop, then the input is valid
    return tuple(move)

"""## General AI Player

Below is the implementation of a general AI with random moves and greedy moves, which will complete a box if it can before doing another random move.
"""

#AI player

#choose a random possible move
def randomAITurn(availableMoves, gameBoard, n, score): #doesn't actually use all these arguments, but makes the funciton prototype consistent
    #chose randomly from the availableMoves list
    move = availableMoves[random.randint(0, len(availableMoves)-1)]
    return move

def findEmptyLine(gameBoard, boxRow, boxCol):
  if gameBoard[boxRow-1, boxCol].isspace():
    return (boxRow-1, boxCol)
  elif gameBoard[boxRow+1, boxCol].isspace():
    return (boxRow+1, boxCol)
  elif gameBoard[boxRow, boxCol-1].isspace():
    return (boxRow, boxCol-1)
  elif gameBoard[boxRow, boxCol+1].isspace():
    return (boxRow, boxCol+1)
  return [-1,-1]


#search for a box that only needs one line, returning a list of what it finds
def boxCanClaim(gameBoard, n):
    movesToClaim = list()
    for i in range(1, n, 2):
        for j in range(1, n, 2):
            if gameBoard[i, j] == 3:
              emptyLineTuple = findEmptyLine(gameBoard, i, j)
              movesToClaim.append(emptyLineTuple)

    return list(set(movesToClaim))

def greedyRandomAITurn(availableMoves, gameBoard, n, score):
    movesToClaim = boxCanClaim(gameBoard, n)
    if len(movesToClaim) >= 1:
        return movesToClaim[random.randint(0, len(movesToClaim)-1)]
    else:
        return randomAITurn(availableMoves, gameBoard, n, score)

"""## Adverserial Search

Below is the implementation of the Minimax function as well as a function to select the best move to play based on the Minimax function output.
"""

#Adverserial Search Algorithm

def Hueristic(n, score):
    return score[0] - score[1]

#Minimax implementation
def minimax(gameBoard, n, isAITurn, playerNum, availableMoves, depth, alpha, beta, score):       ### Last three parameters are for pruning and depth limiting
    #Check is we are at the end of the game or reached max depth
    if len(availableMoves) == 0 or depth == 0:
        return Hueristic(n,score)

    #Goal is to maximize the minimum AI turn
    if isAITurn:
        maxValue = -np.inf # Set starting max value to -infinity
        i = 0
        for i in range(len(availableMoves)):
            scoreCopy = score.copy()
            availMoveCopy = availableMoves.copy()
            move = availMoveCopy.pop(i)
            nextBoard, claimedSquares = makeMove(np.copy(gameBoard), n, move, False, scoreCopy)
            isAITurn = (len(claimedSquares) != 0) # next turn is AI if boxes were claimed

            minimax_value = minimax(nextBoard, n, isAITurn, playerNum, availMoveCopy, depth-1, alpha, beta, scoreCopy)
            maxValue = max(maxValue, minimax_value) #Get new max value

            #Alpha/beta pruning done here
            alpha = max(alpha, minimax_value)
            if beta <= alpha:
              break

        return maxValue

    #Goal is to minimize opponent's turn
    else:
        minValue = np.inf #Set starting min value to infinity
        i = 0
        for i in range(len(availableMoves)):
            scoreCopy = score.copy()
            availMoveCopy = availableMoves.copy()
            move = availMoveCopy.pop(i)
            nextBoard, claimedSquares = makeMove(np.copy(gameBoard), n, move, True, scoreCopy)
            isAITurn = (len(claimedSquares) == 0) # next turn is not isAITurn if boxes were claimed

            minimax_value = minimax(nextBoard, n, isAITurn, playerNum, availMoveCopy, depth-1, alpha, beta, scoreCopy)
            minValue = min(minValue, minimax_value) # Get new min value

            #Alpha/beta pruning done here
            beta = min(beta, minimax_value)
            if beta <= alpha:
              break
        return minValue

#Selects the best move to play next
def bestMove(availableMoves, gameBoard, n, score):

    #Optimization parameters need to be changed for later
    depth = 5
    #scale depth based on avaibleMoves length
    if len(availableMoves) >= 50: # 5x5 grid has 60 total available moves
        depth = 3
    elif len(availableMoves) >= 30: #4x4 grid has 40 total available moves
        depth = 4

    alpha = -np.inf
    beta = np.inf

    bestMove = None

    #Set best value to - infinite if round is even otherwise infinity
    bestValue = -np.inf #if round % 2 ==0 else np.inf
    for i in range(len(availableMoves)):
        scoreCopy = score.copy()
        availMoveCopy = availableMoves.copy()
        move = availMoveCopy.pop(i)

        nextBoard, claimedSquares = makeMove(np.copy(gameBoard), n, move, False, scoreCopy)
        isAITurn = (len(claimedSquares) != 0) #if we claim a square, we get another turn
        minimax_value = minimax(nextBoard, n, isAITurn, 0, availMoveCopy, depth, alpha, beta, scoreCopy)

        if minimax_value > bestValue:
            bestValue = minimax_value
            bestMove = move

    return bestMove

"""## P vs. E

Below is the game logic for Player vs AI gameplay.
"""

import time

def gameFlow(gridSize, AIFunc):
    #initiate the game using gridSize

    #since the struct needs the dots and lines, struct size is n by n, not gridSize by gridSize
    n = gridSize*2 + 1
    #generate an empty board
    gameBoard, availableMoves = initBoard(n)

    #initiate variables
    isPlayersTurn = random.randint(0, 1) #randomly decide who goes first
    claimedBoxes = []
    turnCount = 0
    score = [0,0] # ai in 0, player in 1
    availableBoxes = pow(gridSize, 2)

    #print the empty board
    printBoard(gameBoard, n, (-1,-1), []) #no previous move
    print("") #print newline
    #loop forever
    while 1:
        if isPlayersTurn == 1: #Player's turn
            if (claimedBoxes): #if the last turn got an extra turn, print that instead of normal message
                print("Player got a box, they go again!")
            else:
                print("Player's turn:")

            #player turn accepts input and converts it to (row, col)
            move = playerTurn(gameBoard, n)
            gameBoard, claimedBoxes = makeMove(gameBoard, n, move, isPlayersTurn, score)

        else: #AI's turn
            if (claimedBoxes): #if the last turn got an extra turn, print that instead of normal message
                print("AI got a box, they go again!")
            else:
                print("AI's turn:")

            move = AIFunc(availableMoves, gameBoard, n, score.copy())
            gameBoard, claimedBoxes = makeMove(gameBoard, n, move, isPlayersTurn, score)

        #after anyone takes a turn, these occur
        availableMoves.remove(move) #update availableMoves
        printBoard(gameBoard, n, move, claimedBoxes);
        if (not claimedBoxes): #claimedBoxes is not empty when the move made a box
            isPlayersTurn = (isPlayersTurn + 1) % 2 #change current player 1->0, 0->1
            print("") #print a newline to seperate opposing turns more
        else:
          availableBoxes -= len(claimedBoxes) # decrement boxes

        #turn count is incremented each time someone takes a turn
        turnCount += 1

        #if the board is filled, declare score then break out of loop
        if availableBoxes == 0:
            print("Final scores: Player has", score[1], "points, and AI has", score[0], "points.")
            if score[1] > score[0]:
                print("Player wins!")
            elif score[1] < score[0]:
                print("AI wins!")
            else:
                print("It's a tie!")
            break

"""Below is the simulation for the player to play the game against the general AI player."""

#play the game
print("This is a simulator of \"Dots-and-boxes\", given a grid, each player takes turns drawing either a vertical or horizontal line between two of the dots.\nIf a player draws a line that completes a box, they get another turn. Whoever has the most boxes when the game ends wins!\n")

#get what AI player to play against from input
while 1:
    print("Which player would you like to play against?");
    print("\"Random\", which chooses moves totally at random, \"Greedy\", which claims boxes if they're available but otherwise takes moves randomly, or \"Minimax\", which is a skilled player.")
    AIstr = input("")
    AIstr = AIstr.lower() #convert to lowercase
    if AIstr == "random":
        AIfunc = randomAITurn
        print("Random AI chosen.")
        break
    elif AIstr == "greedy":
        AIfunc = greedyRandomAITurn
        print("Greedy AI chosen.")
        break
    elif AIstr == "minimax":
        AIfunc = bestMove
        print("Minimax AI chosen")
        break
    print("Invalid input, choose \"Random\", \"Greedy\", or \"Minimax\"")

#if we've escaped the loop, then we've chosen our AI function

#get board size from input
minSize = 2
maxSize = 6
while 1:
    gridSize = input(f"Enter size of board (number between {minSize} and {maxSize}): ")
    if gridSize.isnumeric(): #ensure it is a number
        gridSize = int(gridSize)
        if gridSize >= minSize and gridSize <= maxSize: #ensure it's a valid size
            break
    #if any of our ifs fail, we end up here and start over
    print("Invalid input")

print("") #include extra newline
#gameflow initaites the board and has a loop to continue play until no more moves can be made
gameFlow(gridSize, AIfunc)